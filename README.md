Задание 2: [ссылка](https://app.diagrams.net/#G1Wzy88Lb42Vx5A7lgc5ZniYND1mROspan#%7B%22pageId%22%3A%22I4acyg7v4E1xQS31z4bg%22%7D)

### Задание 1.
Уровень 1. Проектирование
Для создания единого приложения в данном случае предпочтителен Webpack Module Federation, т.к.
- У нас нет требований по которым было бы необходимо использовать какой либо ui-framework или ui-библиотеку отличную от React. Поэтому все микрофронтенды будут написаны на одинаковом стеке - на React. Одна из ключевых фичей SingleSPA - framework agnostic - отпадает
- Роутинг будет осуществляться на уровне хостового приложения, и с этим справится с легкостью и Module Federation и SingleSPA
- У меня (в текущем контексте- команды) есть опыт работы с Module Federation
- Каждый из подходов умеет работать с lazy-loading, что мы будем активно использовать для динамической подгрузки модулей
- При всех других равных, выбор пал на Module Federation

Уровень 2. Планирование изменений
Придерживаясь стратегии DDD, монолит разбит на микрофронтенды, указанные ниже списком. Такое разделение позволит командам работать независимо друг от друга, а каждый микрофронтенд будет иметь собственный пакет зависимостей
- host
- shared
- app-auth (Пользователь)
- app-profile (Профиль пользователя)
- app-places (Места)
- app-reactions (лайки и др. сущности реакций)
  Для текущей задачи предпочтительна клиентская run-time интеграция, т.к. у нас нет бизнес-требований по скорости работы или по SEO- оптимизации. В таком случае выбираем наиболее простой подход - клиентская композиция.

### Host
####  Основное приложение
- Корневой компонент App
- Компоненты Layout, Header, Footer
  Функциональность
- Routes и ProtectedRoutes
- Оркестрация "состояния(контекста)", т.е. отвечает за взаимодействие микрофронтендов

### Shared
#### Приложение с переиспользуемыми модулями
- PopupWithForm
- InfoTooltip. Вопреки его содержимому, котороя явно привязано к авторизации, сам тултип стоит сделать независимым от содержания и передавать в него все необходимые параметры через props (например)
- Все возможные общие стили, шрифты, которые можно будет переиспользовать

### app-auth
#### Приложение, отвечающее за доменную область "Пользователь".
Содержит всю функциональность по пользователю, в нашем случае это: аутентификация и регистрация
- Login
- Register
  Так же перенесены utils, которые необходимы только для этого домена
- auth.js

### app-profile
#### Приложение, отвечающее за доменную область "Профиль".
Содержит всю функциональность по ПРОФИЛЮ пользователю, его аватар, описание, имя.
- EditAvatarPopup
- EditProfilePopup
- в этот микрофронтенд был добавлен компонент Profile (вырезанный из компонента Main).

### app-places
#### Приложение, отвечающее за доменную область "Места".
Содержит функциональность, связанную с отображением Мест их загрузки и удалению
- AddPlacePopup
- ImagePopup
- Card - визуализация Места. Кстати, сама компонента Card- кандидат на вынос в модуль shared, если её сделать абстрактной, не привязанной к контексту "Места"
- PlacesList - это перечисление всех Мест

### app-reactions
#### Приложение, отвечающее за доменную область "Реакции".
В частном случае - это отдельный счётчик лайков под Местом. Вынесен в отдельный модуль, т.к. его можно неплохо развить с точки зрения взаимодействия с бекендом. Например, сделать отдельный виджет, который принимает id сущности и посредством long polling в real-time обновляет счётчик лайков. Требует хорошей поддержки бекенда, т.к. аггрегировать результаты по лайкам нужно грамотно спроектировать
- Likes
  Так же следует отметить что подобная конфигурация разбиения на app-reactions позволяет инкапсулировать логику встроенного обработчика события, когда пользователь в оффлайне поставил лайк, затем отменил. В таком случае обработчик отметит что было произведено фактически "отменение" предыдущего события и не будет отправлять запрос на бекенд, когда приложение выйдет в онлайн.

Коммуникации приложений
Определим что именно должно быть в стейте приложения
- пользователь
  - неавторизованный пользователь имеет доступ только к страницам авторизация и регистрации
- профиль
  - профиль можно менять, при этом должно обновиться состояние "саб-хедера"
- список мест
  - список должен пополняться при пополнении и удалении и изменении
- реакции
  - лайки добавляются и отменяются

Теперь, что из этого между собой взаимодействует
- Главным образом - пользователь. Пользователь необходим для каждого микрофронтенда
- отредактированный профиль влияет только сам на себя
- список мест - тоже только на свою компоненту
- реакции - сложный функционал с подпиской на события сервера, но тоже независимый

Итого, получается необходимо шарить только одну сущность между всеми приложениями. Учитывая то что если пользователь разлогинился - он автоматически перемещается на страницу авторизации, то это должен быть однонаправленный шеринг стейта. И именно хост должен быть в ответе за это. Я думаю что в целом, для простого приложения можно всё так же обойтись нативным createContext. Или использовать zustand

Задачи, которые не входят в скоуп задания:
- Желательно применение FSD. Особенно тут хорошо отыграют widgets, потому что много есть компонент со встраиваемыми модулями
- Текущая версия webpack.config дэфолтная, необходима декомпозиция и добавление необходимых плагинов. Особенно важно разделение на prod & dev, т.к. для разных энвов будут разные настройки, главной из которых - "remotes" & "exposes"
- Необходимо настроить eslint, prettier, etc… и вынести это в отдельный приватный node_модуль
- Текущая версия реализации копирует задачу из условия и стили находятся в отдельной папке - blocks. Необходимо перейти на компонентный подход с css модулями
- Необходимо перевести все приложения, webapack.config и т.д. на ts. Не оставить ни следа от js
- Да, про адаптивку тоже можно что-то сделать